---
layout: "../../layouts/NotesLayout.astro"
title: 'Data Structures and Algorithms'
author: 'Zeyu Li'
tags: ["Data Structures and Algorithms", "Computer Science"]
---
import Aside from '../../components/Aside.astro'
import Note from '../../components/Note.astro'
import Tabs from '../../components/Tabs.astro'

## 1 Data Structures and Algorithms Overview

### 1.1 Mathematical Models

Cost Models: Use some basic operations as a proxy for running time.

|       Operation      |                       Frequency                        |
|----------------------|--------------------------------------------------------|
| Variable Declaration |                        $N + 2$                         |
| Assignment Statement |                        $N + 2$                         |
|   Less than Compare  |    $\frac{\left(N + 1\right)\left(N + 2\right)}{2}$    |
|   Equal to Compare   |              $\frac{N\left(N - 1\right)}{2}$           |
|     Array Access     |                 $N\left(N - 1\right)$                  |
|      Increment       |$\frac{N\left(N - 1\right)}{2}$ to $N\left(N - 1\right)$|

Key Notes:
* Estimate running time (or memory) as a function of input size $N$
* Ignore lower order terms
    * When $N$ is large, terms are negligible.
    * When $N$ is small, we don't care.

### 1.2 Order-of-Growth Classifications

### 1.2.1 Common Classifications

<table>
    <thead>
        <tr>
            <td>Order of Growth</td>
            <td>Name</td>
            <td>Typical Code Framework</td>
            <td>Description</td>
            <td>Example</td>
            <td>$T\left(2N\right)/T\left(N\right)$</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>$1$</td>
            <td>Constant</td>
            <td>

            ```cpp
                a = b + c;
            ```

            </td>
            <td>Statement</td>
            <td>Add two numbers</td>
            <td>$1$</td>
        </tr>
        <tr>
            <td>$\log N$</td>
            <td>Logarithmic</td>
            <td>

```cpp
while (N > 1) {
    N /= 2;
}
```

            </td>
            <td>Divide in half</td>
            <td>Binary search</td>
            <td>$-1$</td>
        </tr>
        <tr>
            <td>$N$</td>
            <td>Linear</td>
            <td>

```cpp
for (int i = 0; i < N; i++)
{...}
```

            </td>
            <td>Loop</td>
            <td>Find the maximum</td>
            <td>$2$</td>
        </tr>
        <tr>
            <td>$N \log N$</td>
            <td>Linearithmatic</td>
            <td>See mergesort lecture</td>
            <td>Divide and conquer</td>
            <td>Mergesort</td>
            <td>$-2$</td>
        </tr>
        <tr>
            <td>$N^2$</td>
            <td>Quadratic</td>
            <td>
            
```cpp
for (int i = 0; i < N; i++)
    for (int j = 0; j < N; j++)
        {...}
```
            
            </td>
            <td>Double loop</td>
            <td>Check all pairs</td>
            <td>$4$</td>
        </tr>
        <tr>
            <td>$N^3$</td>
            <td>Cubic</td>
            <td>
            
```cpp
for (int i = 0; i < N; i++)
    for (int j = 0; j < N; j++)
        for (int k = 0; k < N; k++)
            {...}
```
            
            </td>
            <td>Triple loop</td>
            <td>Check all triples</td>
            <td>$8$</td>
        </tr>
        <tr>
            <td>$2^N$</td>
            <td>Exponential</td>
            <td>See combinatorial search lecture</td>
            <td>Exhaustive search</td>
            <td>Check all subsets</td>
            <td>$T\left(N\right)$</td>
        </tr>
    </tbody>
</table>

## 2 Linked List

### 2.1 Singly Linked List

<Tabs tabs={['Java', 'C++', 'Python']}>
    <div id="Java">

```java frame="terminal" collapse={1-68}
// SLList.java
import java.util.Iterator;

public class SLList implements Iterable<Integer> {
    public static class IntNode {
        public int item;
        public IntNode next;

        public IntNode(int i, IntNode n) {
            item = i;
            next = n;
        }
    }

    private final IntNode sentinel;
    private int size;

    public SLList() {
        sentinel = new IntNode(63, null);
        size = 0;
    }

    public SLList(int x) {
        sentinel = new IntNode(63, null);
        sentinel.next = new IntNode(x, null);
        size = 1;
    }

    public void addFirst(int x) {
        sentinel.next = new IntNode(x, sentinel.next);
        size += 1;
    }

    public void addLast(int x) {
        size += 1;
        IntNode p = sentinel;
        while (p.next != null) {
            p = p.next;
        }
        p.next = new IntNode(x, null);
    }

    public int size() {
        return size;
    }

    public Iterator<Integer> iterator() {
        return new SLListIterator();
    }

    private class SLListIterator implements Iterator<Integer> {
        private IntNode p;

        public SLListIterator() {
            p = sentinel.next;
        }

        public boolean hasNext() {
            return p != null;
        }

        public Integer next() {
            int returnItem = p.item;
            p = p.next;
            return returnItem;
        }
    }
}
```
    </div>
    <div id="C">
        
```cpp frame="terminal" collapse={1-66}
// SLList.cpp
#include <iostream>

template <typename T>
class SLList {
public:
    class IntNode {
    public:
        T item;
        IntNode* next;

        IntNode(T i, IntNode* n) {
            item = i;
            next = n;
        }
    };

private:
    IntNode* sentinel;
    int size;

public:
    SLList() {
        sentinel = new IntNode(63, nullptr);
        size = 0;
    }

    explicit SLList(T x) {
        sentinel = new IntNode(63, nullptr);
        sentinel->next = new IntNode(x, nullptr);
        size = 1;
    }

    void addFirst(T x) {
        sentinel->next = new IntNode(x, sentinel->next);
        size += 1;
    }

    void addLast(T x) {
        size += 1;
        IntNode* p = sentinel;
        while (p->next != nullptr) {
            p = p->next;
        }
    p->next = new IntNode(x, nullptr);
    }

    [[nodiscard]] int size_() const {
        return size;
    }

    class iterator {
    private:
        IntNode* current;

    public:
        explicit iterator(IntNode* start) : current(start) {}

        T& operator*() { return current->item; }
        iterator& operator++() { current = current->next; return *this; }
        bool operator!=(const iterator& other) const { return current != other.current; }
    };

    iterator begin() { return iterator(sentinel->next); }
    iterator end() { return iterator(nullptr); }
};
```

    </div>
    <div id="Python">
        
```python frame="terminal" collapse={1-33}
# SLList.py
class SLList:
    class IntNode:
        def __init__(self, i, n):
            self.item = i
            self.next = n

def __init__(self, x=None):
    self.sentinel = self.IntNode(None, None)
    self.size = 0
    if x is not None: # If x is provided, add it as the first element
        self.sentinel.next = self.IntNode(x, None)
        self.size = 1

def addFirst(self, x):
    self.sentinel.next = self.IntNode(x, self.sentinel.next)
    self.size += 1

def addLast(self, x):
    p = self.sentinel
    while p.next is not None:
        p = p.next
        p.next = self.IntNode(x, None)
        self.size += 1

def __len__(self):
    return self.size

def __iter__(self):
    p = self.sentinel.next
    while p is not None:
        yield p.item
        p = p.next
```

    </div>
</Tabs>